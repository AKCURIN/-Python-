import math  # Импорт модуля math для математических операций
import random  # Импорт модуля random для генерации случайных чисел

N = 10  # Количество интервалов в сетке

# Определение функции f(xi)
def f(xi):
    return -6 * xi + q(xi) * U(xi)  

# Определение функции U(xi)
def U(xi):
    return xi**3 + xi / 2 + 2

# Определение функции q(xi)
def q(xi):
    return 2 * xi

h = 1 / N  # Размер шага сетки
m1 = 2  # Граничное условие на левом конце
m2 = 3.5  # Граничное условие на правом конце

# Коэффициенты для трехдиагональной матрицы
Ai = 1 / (h**2)
Bi = 1 / (h**2)

F = []  # Список для хранения значений F(xi)
a = [0] * (N + 1)  # Коэффициенты для метода прогонки
b = [0] * (N + 1)  # Коэффициенты для метода прогонки
b[0] = m1  # Граничное условие на левом конце

# Цикл для построения сетки
for i in range(0, N):
    xi = i * h
    Ci = 2 / h**2 + q(xi)
    F.append(f(xi))
    a[i + 1] = Bi / (Ci - Ai * a[i])
    b[i + 1] = (Ai * b[i] + F[i]) / (Ci - Ai * a[i])

y = []  # Список для хранения численного решения
y = [random.randint(0, 10000) for i in range(10000)]  # Инициализация y случайными значениями
y[N] = m2  # Граничное условие на правом конце
y[0] = m1  # Граничное условие на левом конце

zmax = 0  # Переменная для хранения максимальной ошибки

# Обратная подстановка с использованием метода прогонки
for i in range(N - 1, 0, -1):
    y[i] = a[i + 1] * y[i + 1] + b[i + 1]

# Вычисление максимальной ошибки
for i in range(0, N - 1):
    xi = i * h
    z = abs(y[i] - U(xi))
    if z > zmax:
        zmax = z

print("Норма погрешности=", zmax)  # Вывод максимальной ошибки
