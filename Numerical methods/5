import numpy as np  # Импорт библиотеки NumPy с псевдонимом np

# Определение функции u(x, t), представляющей данное уравнение
def u(x, t):
    return x**3 * t**3 + 2 * x * t + x + 2 

# Определение функции f(x, t), представляющей часть данного уравнения
def f(x, t):
    return 6 * t * x**3 - 6 * x * t**3

# Определение функции u0(x) представляющей начальное условие u0(x)
def u0(x):
    return x + 2

# Определение функции u1(x) представляющей краевое условие u1(x)
def u1(x):
    return 2*x

# Определение функции m1() представляющей краевое условие m1(t)
def m1():
    return 2

# Определение функции m2(t) представляющей краевое условие m2(t)
def m2(t):
    return t**3 + 2 * t + 3

# Определение функции y1(x, tay) представляющей промежуточное значение для краевого условия
def y1(x, tay):
    return 0.5 * pow(tay, 2) * f(x, 0) + u0(x) + tay * u1(x)

# Определение функции NachalZnach(y, h, tay, N, M) для заполнения начальных значений в матрицу y
def NachalZnach(y, h, tay, N, M):
    for i in range(0, N + 1):
        y[i, 0] = u0(i * h)  # Начальные значения вдоль оси x
    for j in range(0, M + 1):
        y[0, j] = m1()  # Значения на границе при t=0
        y[N, j] = m2(j * tay)  # Значения на границе при x=1
    for i in range(1, N):
        y[i, 1] = y1(i * h, tay)  # Промежуточные значения на границе

# Определение функции Progonka(y, N, M, h, tay, sig) для решения задачи с использованием метода прогонки
def Progonka(y, N, M, h, tay, sig):
    gamma = tay / h  # Вычисление значения гамма
    
    for j in range(1, M):
        alf = np.zeros(N + 1)  # Инициализация вектора альфа
        bet = np.zeros(N + 1)  # Инициализация вектора бета
        bet[1] = y[0, j + 1]  # Установка значения бета для первой строки
        alf[1] = 0  # Установка значения альфа для первой строки
        for i in range(1, N):
            Lj = y[i - 1, j] - 2 * y[i, j] + y[i + 1, j]  # Разность вдоль оси x
            Lj1 = y[i - 1, j - 1] - 2 * y[i, j - 1] + y[i + 1, j - 1]  # Разность вдоль оси t
            A = sig * gamma * gamma
            C = 1 + 2.0 * sig * gamma * gamma
            B = sig * gamma * gamma
            F = (2 * y[i, j] - y[i, j - 1]) + gamma * gamma * (1 - 2 * sig) * Lj + sig * gamma * gamma * Lj1 + pow(tay, 2) * f(i * h, j * tay)
            alf[i + 1] = B / (C - A * alf[i])
            bet[i + 1] = (F + A * bet[i]) / (C - A * alf[i])
        for i in range(N, 1, -1):
            y[i - 1, j + 1] = y[i, j + 1] * alf[i] + bet[i]  # Вычисление решения с помощью обратной подстановки

# Определение функции FuncForDerrivativeFu(y, h, tay, N, M) для вычисления значений u(x,t) в каждой точке
def FuncForDerrivativeFu(y, h, tay, N, M):
    for i in range(0, N + 1):
        for j in range(0, M + 1):
            y[i, j] = u(h * i, j * tay)  # Вычисление значений u(x, t)

# Определение функции Max_(y, u, N, M) для вычисления максимального отклонения между вычисленными и реальными значениями
def Max_(y, u, N, M):
    z = float(0)
    for i in range(0, N + 1):
        for j in range(0, M + 1):
            if (z < abs((y[i, j] - u[i, j]) / y[i, j])):
                z = abs((y[i, j] - u[i, j]) / y[i, j])  # Обновление z, если найдено большее отклонение
    return z

# Задание количества шагов по осям x и t
N = 100
M = 100

# Инициализация матриц для хранения вычисленных и реальных значений
y = np.zeros((N + 1, M + 1))
ur = np.zeros((N + 1, M + 1))

# Вычисление шагов по осям x и t
h = 1.0 / N
tay = 1.0 / M

# Заполнение начальных значений в матрицу y
NachalZnach(y, h, tay, N, M)

# Вычисление значений u(x,t) в каждой точке
FuncForDerrivativeFu(ur, h, tay, N, M)

# Решение задачи с помощью метода Прогонки для sigma=0.3
Progonka(y, N, M, h, tay, 0.3)

# Печать максимального отклонения между вычисленными и реальными значениями
print("z для sigma=0.3:", Max_(y, ur, N, M))

# Решение задачи с помощью метода Прогонки для sigma=0.5
Progonka(y, N, M, h, tay, 0.5)

# Печать максимального отклонения между вычисленными и реальными значениями
print("z для sigma=0.5:", Max_(y, ur, N, M))

# Решение задачи с помощью метода Прогонки для sigma=1
Progonka(y, N, M, h, tay, 1)

# Печать максимального отклонения между вычисленными и реальными значениями
print("z для sigma=1:", Max_(y, ur, N, M))
