import numpy as np
import math

# Задаем параметры задачи
n = int(input("Введите n: ")) # Количество узлов сетки
h = 1/n # Шаг сетки
D = np.array([[0, 1], [0, 1]]) # Область D
gamma = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) # Граница gamma это ограничения x1 and x2
f = lambda x: -6 * (2*x[0] + x[1]) # Правая часть уравнения, анонимная функция почти тоже что и def
u = lambda x: 2*x[0] ** 3 + x[1] ** 3 + 2*x[0] + x[1] + 2 # Точное решение
p = 0 # Граничное условие
m1 = lambda x1, x2: 2*x1**3+2*x1+2 # задаём  мю1 - мю4
m2 = lambda x1, x2: 2*x1**3+2*x1+4
m3 = lambda x1, x2: x2**3+x2+2
m4 = lambda x1, x2: x2**3+x2+6   

# Создаем сетку wh и инициализируем массивы y и z
wh = np.zeros((n + 1, n + 1, 2)) # Сетка wh
y = np.zeros((n + 1, n + 1)) # Приближенное решение y
z = np.zeros((n + 1, n + 1)) # Разность между y и u
for i in range(n + 1):
    for j in range(n + 1):
        wh[i, j] = np.array([i * h, j * h]) # Заполняем сетку wh
        y[i, j] = p # Задаем начальное приближение y
        #z[i, j] = y[i, j] - u(wh[i, j]) # Вычисляем разность z
for i in range(0,n+1): #Задаём границы
    y[i,0]=m3(0,i/n)
    y[i,n]=m4(1,i/n)
    y[0,i]=m1(i/n,0)
    y[n,i]=m2(i/n,1)
yo = np.round(y,2)
print(yo) #Выводим начальное приближение
# Задаем параметры итерационных методов
E = float(input("Введите точность E: ")) # Точность и одновременно и есть точка остановки 
w_list = np.arange(0.1, 2, 0.1)  #задаётся список омега

# Проходим по каждому значению w в списке
for w in w_list:
    print("Значение параметра релаксации w: ", round(w, 1)) 
    
    # Инициализируем переменные для итерационных методов
    k = 0 # Счетчик итераций
    max_diff = -1 # Максимальная разность между двумя итерациями

    # Применяем итерационные методы Зейделя и верхней релаксации
    while abs(max_diff) > E: # Пока не достигнем нужной точности
        k += 1 # Увеличиваем счетчик итераций
        max_diff = 0 # Обнуляем максимальную разность
        for i in range(1, n): # Проходим по внутренним узлам сетки
            for j in range(1, n):
                # Вычисляем новое приближение y по формуле
                y_new = w * (y[i - 1, j] + y[i, j - 1] + y[i + 1, j] + y[i, j + 1] + h ** 2 * f(wh[i, j])) / (4 + (1 - w) * h ** 2) + (1 - w) * y[i, j]
                # Обновляем максимальную разность
                max_diff = max(max_diff, abs(y_new - y[i, j]) / y_new) #Относительная погрешность max_diff
                # Обновляем y и z
                y[i, j] = y_new
                z[i, j] = y[i, j] - u(wh[i, j])
    # Выводим результаты
    print("Количество итераций: ", k)
    print("Максимальная норма разности ||z||c: ", np.max(np.abs(z[i, j])))
yo = np.round(y,2)
print(yo)
